# JavaScript API doc generator

This directory contains the script for generating the typescript declaration
file and the typedocs for the JavaScript part of PrimeFaces.

It

1. parses the JavaScript files,
1. extracts the available widgets and their methods,
1. gathers type information from the doc comments,
1. validates that there are no obvious mistakes such as undocumented returns,
1. creates a type declarations file, and
1. generates the JavaScript API documentation.

## Build

Building is integrated into the maven build process, just run

```sh
mvn clean install
```

This will generate the type declaration file in the target directory
`target/type-decarlation/`.

Add the profile `release` to create the JavaScript API documentation:

```sh
mvn clean install -P release
```

The doc files can be found in `doc/<current_version>`.

---

The maven build uses the
[maven frontend plugin](https://github.com/eirslett/frontend-maven-plugin) to
install a local version of `node.js` in the `target` directory.

If you are working on the scripts for generating the type declaration file, you
may want to build directly via npm and node. To do so, first go to the type
definitions directory and run:

```bash
cd src/main/type-definitions
npm install

# All JavaScript files are annotated with types in the doc comments
# This runs TypeScript on the files and validates them
npm run validate

# There are some tests in the specs directory. This runs all tests.
npm run test

# Run just a specific test
node test/index.js -- TsValidateTest --verbose
# Run just a specifc subtest of a test
node test/index.js -- "TsValidateTest#ValidationError" --verbose

# Generates the type declaration file and the API documentation via typedoc
# Writes output to the given directory.
# For local development, use some path outside this project.
npm run generate-d-ts -- \
  --outputDir /path/to/temporary/output/directory \
  --includemodules @fullcalendar,autonumeric,cropperjs,chart.js,googlemaps,jquery,jqueryui,moment,moment-timezone,quill,raphael,vis-data,vis-timeline
```

To see a list of all available options, run 

```bash
npm run generate-d-ts -- --help
```

## Technical overview

More technically speaking, the following steps are performed to create the the
JavaScript API docs::

* Use [acorn](https://www.npmjs.com/package/acorn) to parse the JavaScript
  source code.
* Walk the syntax tree and look for certain patterns, such as
  `PrimeFaces.widget.xxx = Class.extend({...})` and annotations in doc comments,
  such as `@interface` or `@function`. This produces a list of constants,
  objects, and functions that need to be documented.
* For each item to be documented, gather some information:
    * Look a the source code, such as the method signature or the declared
      properties of an object.
    * Parse the doc comments via
      [comment-parser](https://www.npmjs.com/package/comment-parser) and look
      at tags such as `@param` and `@return`.
    * Check for conflicts, such as parameters declared via `@param` that do no
      occur in the method signature.
    * Create a typescript declarations file from this data.
* Create one type declaration (`*.d.ts`) file with all documented items.
    * Run [TypeScript](https://www.npmjs.com/package/typescript) on the
      generated  type declarations file to check for error, such as types that
      do not exist or cannot be resolved (e.g. a misspelled `Jquery`).
    * Make use of the type info generated by TypeScript to check for superfluous
      or missing `@override` tags.
    * For each doc comment with an `@inheritdoc` tag, copy the description from
      the parent type(s) or method(s). This is done because the support for
      the `@inheritdoc` tag  varies widely between various tools.
    * Run [ESLint](https://eslint.org/) with the
      [TypeScript ESLint plugin](https://typescript-eslint.io/) on the final
      type declarations file to check form common mistakes, such as `Function`
      or `Object`.

## TODOs

* Revise this README.md -> tutorial on how to doc a widget

## Questions

* Publish to NPM?
* Update *.MD user guide files?
* Is the workflow / build process ok or should it be changed ?
* Possibly extract the JavaScript / NPM stuff into a maven plugin ?
* Quick smoke test that each widget is still working
* Test build with Windows

## Documenting a widget

You can add doc comments and type annotations directly in the JavaScript code.
During the build process, we parse the JavaScript and extract the relevant doc
comments and types, and generate a type declarations file from that. If you make
any mistakes, you will get a (hopefullly very helpful) warning or error when you
build the the project.

In general, we tried to keep the syntax as close to [jsdoc](https://jsdoc.app)
as possible, but a few customizations (mainly new tags) had to be made to allow
for creating high-quality type declaration files.

You can always take a look at widgets that are already documented to see how
it's done. Below are a few tips to help you get started.

### Basic widget

Let's start with a simple case, a widget that has got some

* some methods,
* some internal state (properties),
* and some configuration (`cfg`)

Let's take the `AccordionalPanel` as an example. Without any documentation, it
looks like this (implementation and some details omitted):

```javascript
PrimeFaces.widget.AccordionPanel = PrimeFaces.widget.BaseWidget.extend({
    init: function(cfg) {
        this._super(cfg);
    }
    initActive: function() {
    },
    bindEvents: function() {
    },
    select: function(index) {
    },
    unselect: function(index) {
    }
});
```

First, we start by adding `@private` to methods that are used only internally
and that we do not want to expose to the public, eg because they are subject to
change. (Note that methods that start with an underscore `_` are exclude by
default. If you want to include them, add `@public`.)

```javascript
PrimeFaces.widget.AccordionPanel = PrimeFaces.widget.BaseWidget.extend({
    init: function(cfg) {
        this._super(cfg);
    }
    
    /**
     * @private
     */
    initActive: function() {
    },

    /**
     * @private
     */
    bindEvents: function() {
    },

    select: function(index) {
    },

    unselect: function(index) {
    }
});
```

Next, we add documentation for the other methods of the widget. A `@param` tag
for the parameters (arguments) and a `@return` tag for the return value. If a
method does not return anything (= no `return <value>` in the code), omit the
`@return` tag.

```javascript
PrimeFaces.widget.AccordionPanel = PrimeFaces.widget.BaseWidget.extend({
    /**
     * @override
     * @inheritdoc
     * @param {PrimeFaces.widget.AccordionPanelCfg} cfg
     */
    init: function(cfg) {
        this._super(cfg);
    }
    
    /**
     * @private
     */
    initActive: function() {
    },

    /**
     * @private
     */
    bindEvents: function() {
    },

    /**
     * Activates (opens) the tab with given index. This may fail by returning `false`, such
     * as when a callback is registered that prevent the tab from being opened.
     * @param {number} index 0-based index of the tab to open. Must not be out of range.
     * @return {boolean} `true` when the given panel is now active, `false` otherwise. 
     */
    select: function(index) {
    },

    /**
     * Deactivates (closes) the tab with given index.
     * @param {number} index 0-based index of the tab to close. Must not be out of range.
     */
    unselect: function(index) {
    }
});
```

For each parameter, we add the type of the parameter in braces, directly after
the tag. If you are wondering what kind of types you can use, see below and
check out the official
[typescript documentation -> basic types](https://www.typescriptlang.org/docs/handbook/basic-types.html).

Did you notice some for the `init` method? It references the
`PrimeFaces.widget.AccordionPanelCfg`. Each widget has got a configuration
object that it receives from the server. This configuration is accessible via
the `cfg` property on the widget instance. So let's specify the structure and
the types of this configuration object. We can do this by adding doc comment
to the widget itself:

```javascript
/**
 * __PrimeFaces AccordionPanel Widget__
 * 
 * The AccordionPanel is a container component that displays content in a stacked format.
 * 
 * @interface {PrimeFaces.widget.AccordionPanelCfg} cfg The configuration for the {@link  AccordionPanel| AccordionPanel widget}.
 * You can access this configuration via {@link PrimeFaces.widget.BaseWidget.cfg|BaseWidget.cfg}. Please note that this
 * configuration is usually meant to be read-only and should not be modified.
 * @extends {PrimeFaces.widget.BaseWidgetCfg} cfg
 * @prop {number[]} cfg.active List of tabs that are currenty active (open). Eaach item is a 0-based index of a tab.
 * @prop {boolean} cfg.cache `true` if activating a dynamic tab should not load the contents from server again and use
 * the cached contents; or `false` if the caching is disabled.
 * @prop {string} cfg.collapsedIcon The icon class name for the collapsed icon.
 * @prop {boolean} cfg.controlled `true` if a tab controller was specified for this widget; or `false` otherwise. A tab
 * controller is a server side listener that decides whether a tab change or tab close should be allowed.
 * @prop {boolean} cfg.dynamic `true` if the contents of each panel are loaded on-demand via AJAX; `false` otherwise.
 * @prop {string} cfg.expandedIcon The icon class name for the expanded icon.
 * @prop {boolean} cfg.multiple `true` if multiple tabs may be open at the same time; or `false` if opening one tab
 * closes all other tabs.
 * @prop {boolean} cfg.rtl `true` if the current text direction `rtl` (right-to-left); or `false` otherwise.
 */
PrimeFaces.widget.AccordionPanel = PrimeFaces.widget.BaseWidget.extend({
    /**
     * Initializes this accordion widget and sets up all events.
     * @param {PrimeFaces.widget.AccordionPanelCfg} cfg Configuration as created in the renderer.
     */
    init: function(cfg) {
        this._super(cfg);
    }
    
    /**
     * @private
     */
    initActive: function() {
    },

    /**
     * @private
     */
    bindEvents: function() {
    },

    /**
     * Activates (opens) the tab with given index. This may fail by returning `false`, such
     * as when a callback is registered that prevent the tab from being opened.
     * @param {number} index 0-based index of the tab to open. Must not be out of range.
     * @return {boolean} `true` when the given panel is now active, `false` otherwise. 
     */
    select: function(index) {
    },

    /**
     * Deactivates (closes) the tab with given index.
     * @param {number} index 0-based index of the tab to close. Must not be out of range.
     */
    unselect: function(index) {
    }
});
```

Alright, this might be a lot at once, but let's take a look at each part:

* `@interface {PrimeFaces.widget.AccordionPanelCfg} cfg`
    * This defines the name of the widget configuration object. By convention,
      we use the name of the widget with the suffix `Cfg`.
    * In case you are curious, yes, this means a new `interface` will be created
      in the type declaration file.
* `@extends {PrimeFaces.widget.BaseWidgetCfg} cfg`
    * This makes the configuration inherit all properties from the base widget
      configuration. This includes properties such as `id` and `widgetVar`. This
      way, we can just inherit them and do not have to specify them ourselves.
* `@prop {PrimeFaces.widget.AccordionPanelCfg} cfg`
    * Now that we created an interface, we can add a `cfg` property and simply
      make its type that interface.
* `@prop {number[]} cfg.active`
    * To specify the properties of the configuration object, we add more `@prop`
      tags. The property will be named `active`, but we need to add `cfg.` to
      indicate that this is a property of the configuration object, not of the
      widget itself.

Now we are almost done. The widget has also got some properties of its own,
which we also add to the header:

```javascript
/**
 * __PrimeFaces AccordionPanel Widget__
 * 
 * The AccordionPanel is a container component that displays content in a stacked format.
 * 
 * @prop {JQuery} headers The DOM elements for the header of each tab.
 * @prop {JQuery} panels The DOM elements for the content of each tab pabel.
 * 
 * @interface {PrimeFaces.widget.AccordionPanelCfg} cfg The configuration for the {@link  AccordionPanel| AccordionPanel widget}.
 * You can access this configuration via {@link PrimeFaces.widget.BaseWidget.cfg|BaseWidget.cfg}. Please note that this
 * configuration is usually meant to be read-only and should not be modified.
 * @extends {PrimeFaces.widget.BaseWidgetCfg} cfg
 * @prop {number[]} cfg.active List of tabs that are currenty active (open). Eaach item is a 0-based index of a tab.
 * @prop {boolean} cfg.cache `true` if activating a dynamic tab should not load the contents from server again and use
 * the cached contents; or `false` if the caching is disabled.
 * @prop {string} cfg.collapsedIcon The icon class name for the collapsed icon.
 * @prop {boolean} cfg.controlled `true` if a tab controller was specified for this widget; or `false` otherwise. A tab
 * controller is a server side listener that decides whether a tab change or tab close should be allowed.
 * @prop {boolean} cfg.dynamic `true` if the contents of each panel are loaded on-demand via AJAX; `false` otherwise.
 * @prop {string} cfg.expandedIcon The icon class name for the expanded icon.
 * @prop {boolean} cfg.multiple `true` if multiple tabs may be open at the same time; or `false` if opening one tab
 * closes all other tabs.
 * @prop {boolean} cfg.rtl `true` if the current text direction `rtl` (right-to-left); or `false` otherwise.
 */
PrimeFaces.widget.AccordionPanel = PrimeFaces.widget.BaseWidget.extend({
    /**
     * Initializes this accordion widget and sets up all events.
     * @param {PrimeFaces.widget.AccordionPanelCfg} cfg Configuration as created in the renderer.
     */
    init: function(cfg) {
        this._super(cfg);
    }
    
    /**
     * @private
     */
    initActive: function() {
    },

    /**
     * @private
     */
    bindEvents: function() {
    },

    /**
     * Activates (opens) the tab with given index. This may fail by returning `false`, such
     * as when a callback is registered that prevent the tab from being opened.
     * @param {number} index 0-based index of the tab to open. Must not be out of range.
     * @return {boolean} `true` when the given panel is now active, `false` otherwise. 
     */
    select: function(index) {
    },

    /**
     * Deactivates (closes) the tab with given index.
     * @param {number} index 0-based index of the tab to close. Must not be out of range.
     */
    unselect: function(index) {
    }
});
```

To finish the widget documentation, we can add additional tags, such as
`@author` (who wrote the widget?) or `@since` (which version was it added?).

## Advanced documenting

Sometimes types are getting more complex. Below are some of the more common
cases. See also the tests in `src/main/type-definitions/specs/` for more
examples.

## Excluding source files

All JS files in `src/main/resources/META-INF/resources/primefaces` are processed
by default. Some of those files are third-party libraries and some have got
JSDoc comments that are invalid. To prevent these libraries from being processed
at all, add them to the blacklist in `src/main/type-definitions/blacklist.txt`:

```
# List of files to be excluded from the type declaration file.
# Mainly third-party libraries we do not want to document.
chartjs/0-chartjs.js
charts/0-jqPlot.js
keyboard/0-jquery.keypad.js
touch/touchswipe.js
```

### Additional type declarations

If you need to do advanced typings that cannot be done via doc comments, you
can create a separate `*.d.ts` file in a widget directory. As long as it ends
in `.d.ts`, is is picked up automatically:

* src/main/resources/META-INF/resources/primefaces
    * accordion
        * accordion.js
        * 01-SomeTypes.d.ts
        * 02-MoreTypes.d.ts
    * calendar
        * calendar.js
        * AdditionalDeclarations.d.ts

In case more that one type declaration files are found for a component, the
files are sorted alphabetically.

## Overriding a method

Sometimes a subclass overrides a method of the base class. In this, case add the
`@override` tag. If you want to inherit the doc comment from the parent class as
well, also add the `@inheritdoc` tag. This tag only inherits the documeation,
not the typings of the method. This means you still need to add the `@param` and
`@return` tags to indicate the type, but you can leave the description empty:

```javascript
PrimeFaces.widget.SubWidget = PrimeFaces.widget.BaseWidget.extend({
    /**
     * @override
     * @inheritdoc
     * @param {number} index
     * @return {JQuery}
     */
    getItem: function(index) {
        // ...
    },
});
```

### Typedefs

If you need to add a type for convenience, you can do so via `@typedef` tag:

```javascript
/**
 * @typedef {{r: number, g: number, b: number}} RgbColor
 */
PrimeFaces.widget.Typedef = PrimeFaces.widget.BaseWidget.extend({
    /**
     * @return {RgbColor} color
     */
    getColor: function() {
        // ...
    }
    /**
     * @param {RgbColor} color
     */
    setColor: function(color) {
        // ...
    },    
});
```

This will generate something like:

```typescript
namespace PrimeFaces.widget {
    export type RgbColor = {r: number, g: number, b: number};
    export class Typedef extends BaseWidget<TypedefCfg> {
        getColor(): RgbColor;
        setColor(color: RgbColor): void;
    }
}
```

Note that you can also use the `@typedef` tag on a method, this will behave the
same way as if you had added it to the widget.

Note however, that I personally prefer putting these additional declarations in
a separate `.d.ts` file.

### Generics

Generic type parameters are supported for methods via the `@template` tag. You
can also specify a bound for the type parameter:

```javascript
PrimeFaces.widget.Destructured = PrimeFaces.widget.BaseWidget.extend({
    /**
     * @template T Type of an object
     * @template {keyof T} K Type of the key to access
     * @param {T} object Any object
     * @param {K} key A key in the object
     * @return {T[K]} The value  at the given key in the object
     */
    genericMethod: function(object, key) {
        // ...
    },
});
```

This will generate something like:

```typescript
function genericMethod<T, K extends keyof T>(object: T, key: K): T[K];
```

### Optional parameters and initializers

To indicate that a parameter of a method is optional, enclose its name in
brackets:

```javascript
PrimeFaces.widget.Optional = PrimeFaces.widget.BaseWidget.extend({
    /**
     * @param {number} x
     * @param {number} [y] Don't make the type number | undefined
     * @param {number} [z = 42] Set a default value 
     */
    oneToThreeArgs: function(x,y,z) {
        // ...
    },
});
```

This will generate something like:

```typescript
function oneToThreeArgs(x: number, y?: number, z: number = 42): void;
```

### Destructuring

Destructured parameters are supported by the parser. But please check out the
style guide for the JavaScript. As of now, ES6 features should not be used.

```javascript
PrimeFaces.widget.Destructured = PrimeFaces.widget.BaseWidget.extend({
    /**
     * You need to add a param annotation for each declared symbol that is made
     * available to the function scope. The type annotation, however, must be
     * declared for the entire positional argument - don't add a type for
     * destructured symbols, and add pattern tag instead.
     * 
     * @param {string} normalParam the param x - type annotation as normal
     * @param y1 the param y1 - no type annotation
     * @param y2 the param y2 - no type annotation
     * @param z the param z - no tag for z2, as z2 does not exist as a variable within the function
     * @param k the param k
     * @pattern {{x: string, y: {y1: number, y2: number}, z2: boolean}} 1 Type declaration for the destructured argument
     * at position=1
     * @pattern {MapFromCharacterToCode} 2 Type declaration for the destructured argument at position=2
     * @return {RegExp} the return value with its type as normal
     */
    destructureObject: function(normalParam, {x, y: {y1, y2}, z2: z }, {k}) {
        /// ... implementation ...
    },

    /**
     * For arrays, it works the same way as it does for objects.
     * 
     * @param {string} normalParam
     * @param y1 the param y1
     * @param y2 the param y2
     * @param z the param z
     * @param k the param k
     * @pattern {[string, [number, number]]} 1
     * @pattern {boolean[]} 2
     * @return {RegExp}
     */
    destructureArray: function(normalParam, [x, [y1, y2]], [z, ...k]) {
        /// ... implementation ...
    }
});
```

If you need to support destructured parameters for a a method in a property (
widget configuration or otherwise), you need to describe the structure
explicitly, as no code is available:

```javascript
/**
 * @param {PrimeFaces.widget.DemoCfg} cfg
 * @structure {{x, y2: y}} cfg.check.1
 * @structure {{z}} cfg.check.2
 * @pattern {{x: number, y2: string}} cfg.check.1
 * @pattern {Vector3} cfg.check.2
 * @method cfg.check
 * @param {boolean} cfg.check.normal
 * @param cfg.check.x
 * @param cfg.check.y
 * @param cfg.check.z
 * @return {string}
 */
PrimeFaces.widget.Demo = PrimeFaces.widget.BaseWidget.extend({
});
```

This will generate something like this:

```typescript
namespace PrimeFaces.widget {
    export class Demo extends BaseWidget<DemoCfg> {
        cfg: DemoCfg;
    }
    export interface DemoCfg {
        check(normal: boolean, {x, y2: y}: {x: number, y2: string}, {z}: Vector3): string;
    }
}
```

### Asynchronous methods and generators

Asynchronous methods and generators are recognized automatically by their
syntax. The return type is modified automatically, so just write down the base
type:

```javascript
PrimeFaces.widget.Destructured = PrimeFaces.widget.BaseWidget.extend({
    /**
     * @return {string}
     */
    doWork: async function() {
        // ...
    },
    /**
     * @return {string}
     */
    list: function* () {
        // ...
    },
    /**
     * @return {string}
     */
    listFromNetwork: async function* () {
        // ...
    }
});
```

This will generate something like:

```typescript
function doWork(): Promise<string>;
function list(): IterableIterator<string>
function listFromNetwork(): AsyncIterableIterator<string>;
```


## Style and conventions

If you want to contribute, that's great. For the sake of consistency, please
keep to our style guide.

### Private and public methods

There are no hard or clear-cut rules to decide whether a method should be
private (not appear in the documentation) or part of the public API. Part of the
motivation behind creating a type declaration file was that it makes it possible
to check existing JavaScript code against the API. When you know a method is not
available anymore you can change it and catch bugs early. So you do not have to
be overly protective when deciding which methods to expose, but proceed with
care. Ask yourself the following question:

* Is this method temporary, deprecated or will it change soon?
* How "useful" is this method, what could people do if it were exposed?
* Does the method actually work standalone, or does it require several
  other actions? (Eg. `ColumnToggler#check` is, despite its name, only a handler
  for the event after the user checked a checkbox - just calling this method
  will do every thing a click on the checkbox would,
  *except actually checking the checkbox*)
* Is this method essential, or are there other ways to achieve the same goal?
* How many camel-case words does the method name consist of, and
* How many words do you need to describe what this method does? If you need too
  many, it's probably some very specific internal helper method.
* Is it used only in the `init` method? That's a good sign of an internal
  method.

Here are some common traits for methods that should most likely be private:

* Methods that perform initial setup and event binding, often called `bind...`,
 `setup...`, `listen...`, or `attach...`
* Internal logic, such as `clearCache`, `processKeyEvents`, `invoke...` or
  `compute...`.

### Doc comments

These are just some general guidelines to keep the documentation consistent, you
do not have to follow every single rule to the letter.

* Try to make doc comments helpful. For example, if you're documenting a getter
  method, you don't have to spell out `Returns the foo`. Instead, try answering
  questions a consumer of a library might have, such as
    * What is foo?
    * Does it cache the foo or create a new one each time?
    * What's the unit of foo?
    * Does it have any other side effects?
    * If the type is `JQuery`, which elements are allowed exactly? (Usually it
      helps to mention the style class of acceptable elements, such as
      `.ui-chkbox-box`.)
    * (for methods) Can I pass `undefined` and what happens if I do?
    * (for methods) Can it throw an error?
    * (for methods) When does it throw an error?
    * (for methods) What does the method do, are there any performance
      limitations?
    * (for params / return values) If it's a physical value, which unit does it
      have (eg. milliseconds)
    * (for params / return values) If it's an index, is it 0-based or 1-based?
    * (for params / return values) If it's a range, is inclusive (`[1,10]`) or
      exclusive (`(1,10)`)?
    * (for callbacks) What do I need to return for which circumstance?
    * (for callbacks) What happens if I throw an error?
    * ...
* Limit doc comments to at most 120 characters per line. This limit includes the
  indentation at the beginning of the line. The only exception are long typedefs.
* Use markup syntax in doc comments, avoid using plain HTML.
* If a `@param` can be `null` or `undefined`, describe what happens if it is:
  Will it throw an error, will it return immediately without doing anything
  useful, will it substitute some default value (which?), or something else?
* If a `@return` can be `null` or `undefined`, describe why and when this
  happens.
* Keep the description on `@return` and `@param` short and to the point, add
  more details in the main doc comment description.
* Prefer third-person: `Deactivates the behavior` instead of
  `Deactivate the behavior`
* Prefer simple, active voice constructions when possible:
  `So that the user can no longer select a date` instead of
  `So that no date can be selected anymore` or
  `So that no date is selectable any longer`.
* Inside a class, refer to the the instance by the word `this`. For example, the
  documentation for the method `start` of the `Clock` widget should read
  `Starts this clock if not already running`, not `Starts (the/a) clock...`
* Prefer American English spellings, eg `behavior`, `color`, `meter`, `license`,
  `localization`, `maximize`, `dialog`, `canceled`, `resizable`, `dependent`,
   `tidbit`.
* All tags such as `@param`, `@return` etc. need to come last, after the
  description. If you try and add a description for a method or property after a
  tag, the parser will interpret it as part of the tag's description.
* Some tags have multiple names, and while neither is wrong, to keep it
  consistent:
    * use `@return` instead of `@returns`
    * use `@prop` instead of `@property` 
* Keep tags of the same type together. If possible, try to keep tags in this
  order:
    * @typedef
    * @override
    * @class / @interface
    * @public / @protected / @private / @internal / @abstract
    * @inheritdoc
    * @template
    * @prop
    * @method
    * @param
    * @return
    * @see
    * @author

### Typescript types

Some guidelines for annotating properties, parameters and return values with
types:

* Follow common typescript conventions, see for example
  [Do's and Don'ts](https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html)
* Use the `string`, `number`, `boolean` instead of `String`, `Number`, `Boolean`
* Use import types when possible: `import("chart.js").ChartConfiguration`. Not
  possible for global declarations such as `JQuery`.
* Do not use `object` if it can be avoided. If possible, describe the shape of
  the object, such as `{x: string, y: number}`. For generic objects that behave
  like a map, use  for example `Record<string, number>`.
* For arrays, use `string[]` or `JQuery[][]` instead of `Array<string>` and
  `Array<JQuery>[]` 
* Use only `undefined`, unless the code you are describing absolutely requires
  the use of the type `null`
* But be explicit about `nullness`: If a method may return either a string or
  nothing, the return value is `string | undefined`. (If it never returns a
  value, the return type is `void`.)
* Try making the name of type parameters more descriptive, such as
  `Class<TConfig>` instead of `Class<T>`. But please keep them short.
* Add a default for a type parameter whenever possible, especially when the type
  parameter is bounded:
  
```typescript
    export function doSomethingWithWidget<
        TWidget extends PrimeFaces.widget.BaseWidget = PrimeFaces.widget.BaseWidget
    >(widget: TWidget) {
        // ...
    }
```
